Клас `longM` реалізує поняття _I-структури_, тобто об'єкта з полем `Long`, яке монотонно змінюється від початкового стану "невизначений", "неготовий".
 до стану, "визначений" з визначеним "Long" методом `set`, а потім, можливо, до стану "перевизначеного", "суперечливого" додатковим викликом
`set` з нерівним значенням, реалізованого як виключення.
Метод `get` _призупиняє_ поточну корутину, якщо об'єкт знаходиться в стані "неготовий", доки він не стане "визначеним" після виклику `set`.

Реалізація базується на Kotlin корутинах (https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html), які представляють з себе легковісні паралельні потоки.
Корутина — це набір функцій, позначених модифікаторами `suspend` і, можливо, звичайними функціями, які викликала остання функція `suspend`.
Функція `launch` створює нову корутину, яка буде паралельно запущена, коли буде доступний вільний потік.

Кожен об’єкт `LongM` використовує власний приватний об'єкт класу `Suspender` у полі `unready`.
Цей об’єкт зберігає чергу корутин, які були призупинені викликом методу `suspend` (у операторі `unready?.suspend()`).
Призупинені корутини звільняються методом `releaseAll`.
`suspend` і `releasedAll` аналогічні стандартним методам `wait` і `notifyAll` у Java.

Файл `Fib.kt` демонструє використання об'єктів `LongM` для обчислення чисел Фібоначчі за лінійний час завдяки запам'ятовуванню чисел в об'єктах.
